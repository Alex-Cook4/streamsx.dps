<?xml version="1.0" encoding="UTF-8"?>
<functionModel xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.ibm.com/xmlns/prod/streams/spl/function" xmlns:cmn="http://www.ibm.com/xmlns/prod/streams/spl/common" xsi:schemaLocation="http://www.ibm.com/xmlns/prod/streams/spl/function functionModel.xsd">
  <functionSet>
    <headerFileName>DistributedProcessStoreWrappers.h</headerFileName>
    <functions>
      <function>
        <description>Create a new process store with a given name.
@param name the name of the store to create
@param key this variable should be provided to indicate the type of the key to use in the store.
@param value this variable indicates the type of the values in the store. 
@param err  mutable variable provided that will contain the error code, if an error occurs. Will be set to '0' if the store was created successfully, or a non-zero value otherwise.  To get detailed information about the most recent store related error, call the `dpsGetLastStoreErrorCode` and the `dpsGetLastStoreErrorString` functions.      
@return the process store handle if created. It is advisable to cache the store id in your application.  The return value will be '0' if a process store with the same name already exists, and undefined if there is an error.

		mutable uint64 err = 0ul;
		mutable uint64 s = 0ul;
		rstring dummyRstring = "";
		uint32 dummyUint32 = 0u;
		s = dpsCreateStore("myDBStore1", dummyRstring, dummyUint32, err);
	
		if (err != 0ul) {
   			uint64 rc = dpsGetLastStoreErrorCode;
   			rstring msg = dpsGetLastStoreErrorString();
   			printStringLn("Unexpected error in creating a store named myDBStore1: rc = " + 	(rstring)rc + ", msg = " + msg);
		}
			
</description>
       <prototype>&lt;any T1, any T2> public stateful uint64 dpsCreateStore(rstring name, T1 key, T2 value, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Create a new process store with a given name or simply return its handle it already exists.
@param name the name of the store to retrieve, or to create if it doesn't already exist.
@param key this variable should be provided to indicate the type of the key to use in the store.
@param value this variable indicates the type of the values in the store.
@param err mutable variable provided that will contain the error code, if an error occurs. Will be set to '0' if the store was created successfully, or a non-zero value otherwise.  To get detailed information about the most recent store related error, call the `dpsGetLastStoreErrorCode` and the `dpsGetLastStoreErrorString` functions.      
@return the process store handle of the created store.  If an error occurs, the return value of this function is undefined. It is recommended that the store id is cached in your application. 
        </description>
        
        <prototype>&lt;any T1, any T2> public stateful uint64 dpsCreateOrGetStore(rstring name, T1 key, T2 value, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Find a process store given its name. 
@param name the name of the store to look up.        
@param err this parameter will be set by the function to contain the error code if an error occurs finding the store, and '0' otherwise.        
@return the process store handle if found, 0 otherwise.</description>
        <prototype>public stateful uint64 dpsFindStore(rstring name, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Remove a process store given its handle.
@param store the process store handle identifying the store to remove.
@param err this parameter will contain the error code, if an error occurs. Or will be set '0' if the remove operation was successful.         
@return true if the store existed and was succesfully removed.
	
	
	mutable boolean result = true;
	result = dpsRemoveStore(dbStore_handle, err);

	if (err != 0ul) {
		uint64 rc = dpsGetLastStoreErrorCode();
		printStringLn("Unexpected error in removing a store: rc = " + (rstring)rc + ", msg = " + dpsGetLastStoreErrorString());
	}	
		

</description>
        <prototype>public stateful boolean dpsRemoveStore(uint64 store, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Put a new key-value pair into a store.  This function has better performance than `dpsPutSafe` since no safety checks are done. The specified **key** and **item** must be of the same type as those used to create the store in `dpsCreateStore`  or `dpsCreateOrGetStore`, otherwise, store operations will produce undesired results.
@param store the handle specifying the store.        
@param key the key for the new pair.        
@param item the value for the new pair. Must be the same type as the **value** that was provided when the store was created.
@param err will be set to '0' on success, and will be non-zero otherwise. To get detailed information about the most recent store related error, call the `dpsGetLastStoreErrorCode` and the `dpsGetLastStoreErrorString` functions.       
@return If no error occurs, returns false if the item previously existed in the store, and true if the store did not contain an item with the same key.
     
		rstring dummyRstring = "";
		uint32 dummyUint32 = 0u;
		mutable uint64 err = 0ul;
		dbStore_handle = dpsCreateStore("myDBStore1", dummyRstring, dummyUint32, err);

		//..perform error checks	
		
		mutable uint64 err = 0ul;
		mutable boolean result = true;
		rstring key = "IBM";
		uint32 value = 399;
		err = 0ul;
		result = dpsPut(dbStore_handle, key, value, err);
		
		if (err != 0ul) {
			//use  dpsGetLastStoreErrorCode() and  dpsGetLastStoreErrorString() as needed
		}		
		     
         </description>
        <prototype>&lt;any T1, any T2> public stateful boolean dpsPut(uint64 store, T1 key, T2 item, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Put an item into the given store. This function is identical to `dpsPut`, however, it performs additional safety checks.  As a result, this function will be slower than `dpsPut`.
@return If no error occurs, returns false if the item previously existed in the store, and true if the store did not contain an item with the same key.
</description>
        <prototype>&lt;any T1, any T2> public stateful boolean dpsPutSafe(uint64 store, T1 key, T2 item, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Put an key-value pair with a TTL (Time To Live in seconds) value into the global area of the back-end data store. The **key** and **value** can be any SPL type.
@param key the key with which to associate the given value
@param item the value to associate with the key
@param ttl the amount of time, in seconds, this pair will be kept in the TTL store before it's automatically removed. A value of '0' means that this pair will be in the store indefinitely until manually removed via `dpsRemoveTTL`.
@param err will be set to '0' if the operation was successful, and a non-zero value otherwise.   To get detailed information about the most recent TTL store related error, call the `dpsGetLastErrorCodeTTL` and the `dpsGetLastErrorStringTTL` functions.    
@return true if the operation is successful, false otherwise.
        
        mutable rstring myKey = "", myValue = "";
		myKey = "New York";
		myValue = "Albany";
		mutable uint64 err = 0ul;
		// Put a K/V pair with 5 seconds of TTL.
		boolean res = dpsPutTTL(myKey, myValue, 5u, err);
	                    
		if (res == false) {
           //handle error using dpsGetLastErrorCodeTTL() and  dpsGetLastErrorStringTTL());
		}
        
        </description>
        
        <prototype>&lt;any T1, any T2> public stateful boolean dpsPutTTL(T1 key, T2 item, uint32 ttl, mutable uint64 err)</prototype>
      </function>           
      <function>
        <description>Given a key, retrieves its value from the given store. This function has better performance than `dpsGetSafe` since it doesn't carry out any safety checks.
@param store the handle identifying the store in question.
@param key the key of the item to look up
@param item if the key exists in the store and has a value of the same type, this parameter will be set to the key's value.         
@param err contains the non-zero error code, if an error occurs, or will have a value of '0'.
@return  true if the if the operation was successful and the store contains an item with the given key and a matching type, and false if the key-value pair wasn't found.
       </description>
        <prototype>&lt;any T1, any T2> public stateful boolean dpsGet(uint64 store, T1 key, mutable T2 item, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Given a key, retrieve its value from the given store. Returns true if the store did contain an item with the given key and a matching type, false otherwise.  This function is identical to `dpsGet`, with the exception that
it does safety checks and is therefore slower.</description>
        <prototype>&lt;any T1, any T2> public stateful boolean dpsGetSafe(uint64 store, T1 key, mutable T2 item, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Get an item that was stored with a TTL (Time To Live in seconds) value into the global area of the back-end data store.
        Returns true if the store did contain an item with the given key and a matching type, false otherwise.</description>
        <prototype>&lt;any T1, any T2> public stateful boolean dpsGetTTL(T1 key, mutable T2 item, mutable uint64 err)</prototype>
      </function>      
      <function>
        <description>Remove an item from the given store. Returns true if the store did
       contain an item with the given key, false otherwise.</description>
        <prototype>&lt;any T1> public stateful boolean dpsRemove(uint64 store, T1 key, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Remove an item that was stored with a TTL (Time To Live in seconds) value into the global area of the back end data store.
        Returns true if an item with the given key was removed, false otherwise.</description>
        <prototype>&lt;any T1> public stateful boolean dpsRemoveTTL(T1 key, mutable uint64 err)</prototype>
      </function>        
      <function>
        <description>Check if an item exists. Returns true if the given store does
       contain an item with the given key, false otherwise.</description>
        <prototype>&lt;any T1> public stateful boolean dpsHas(uint64 store, T1 key, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Check if an item exists that was store with a TTL (Time To Live in seconds) value. 
        Returns true if an TTL item with the given key exists, false otherwise.</description>
        <prototype>&lt;any T1> public stateful boolean dpsHasTTL(T1 key, mutable uint64 err)</prototype>
      </function>        
      <function>
        <description>Clear the given store.</description>
        <prototype>public stateful void dpsClear(uint64 store, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Get the size of the given store.</description>
        <prototype>public stateful uint64 dpsSize(uint64 store, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Begin the iteration on a given store. No other operations that can modify
        the state can be used until after a matching gsEndIteration()
        call. Returns the iterator.</description>
        <prototype>public stateful uint64 dpsBeginIteration(uint64 store, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Get the next key and value of given types in the given store. Returns true if an item was
        found, false otherwise.</description>
        <prototype>&lt;any T1, any T2> public stateful boolean dpsGetNext(uint64 store, uint64 iterator, mutable T1 key, mutable T2 value, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>End the iteration on the given store.</description>
        <prototype>public stateful void dpsEndIteration(uint64 store, uint64 iterator, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Serialize all the items in the given store.</description>
        <prototype>&lt;any T1, any T2> public stateful void dpsSerialize(uint64 store, mutable blob data, T1 dummyKey, T2 dummyValue, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Deserialize the items from the serialized store.</description>
        <prototype>&lt;any T1, any T2> public stateful void dpsDeserialize(uint64 store, blob data, T1 dummyKey, T2 dummyValue, mutable uint64 err)</prototype>
      </function>
      <function>
        <description>Get the description of the last store error.
@return the error message, or the empty string if the last data store operation was successful.</description>
        <prototype>public stateful rstring dpsGetLastStoreErrorString()</prototype>
      </function>
      <function>
        <description>Get the description of the last error occurred for a TTL data item.
@return the error message, or the empty string if the last TTL store operation was successful.        </description>
        <prototype>public stateful rstring dpsGetLastErrorStringTTL()</prototype>
      </function>  
      <function>
        <description>Get the error code of the last store error.
@return the error code for the last store operation or '0' if the last operation was successful.        </description>
        <prototype>public stateful uint64 dpsGetLastStoreErrorCode()</prototype>
      </function>
      <function>
        <description>Get the error code of the last error ocuured for a TTL data item.
@return the error code, or '0' if the last TTL store operation was successful.        </description>
        <prototype>public stateful uint64 dpsGetLastErrorCodeTTL()</prototype>
      </function>  
      <function>
        <description>Get the store name for a given store id.
@param store the store to look up
@return the name used to create the store, if it exists.        </description>
        <prototype>public stateful rstring dpsGetStoreName(uint64 store)</prototype>
      </function>
      <function>
        <description>Get the SPl type name for the key of a given store id.
@param store the handlef or the store in question.
@return the type for the keys in the store.        </description>
        <prototype>public stateful rstring dpsGetSplTypeNameForKey(uint64 store)</prototype>
      </function>
      <function>
        <description>Get the SPl type name for the value of a given store id.
@param store the handle for the store in question
@return the type for the values in the store
</description>
        <prototype>public stateful rstring dpsGetSplTypeNameForValue(uint64 store)</prototype>
      </function>
      <function>
        <description>Get the name of the NoSQL DB product being used.</description>
        <prototype>public stateful rstring dpsGetNoSqlDbProductName()</prototype>
      </function>
      <function>
        <description>Get details of the client machine where this operator is running.  
You must pass three mutable rstring variables as the three function arguments in which the machine name, Linux OS version and the CPU architecture (x86 or PPC) will be assigned for your use.
@param machineName the machine's name.
@param osVersion Linux OS version.
@param cpuArchitecture cpu architecture of the client.</description>
        <prototype>public stateful void dpsGetDetailsAboutThisMachine(mutable rstring machineName, mutable rstring osVersion, mutable rstring cpuArchitecture)</prototype>
      </function>      
      <function>
        <description>
           If users want to execute simple arbitrary back-end data store (fire and forget)
           native commands, this API can be used. This covers any Redis or Cassandra(CQL)
           native commands that don't have to fetch and return K/V pairs or return size of the db etc.
           (Insert and Delete are the more suitable ones here. However, key and value can only
            have string types.)
        </description>
        <prototype>public stateful boolean dpsRunDataStoreCommand(rstring cmd, mutable uint64 err)</prototype>
      </function> 
      <function>
        <description>
           If users want to execute arbitrary back-end data store two way
           native commands, this API can be used. This is a variation of the previous API with
           overloaded function arguments. As of Nov/2014, this API is supported in the dps toolkit only
           when Cloudant or HBase NoSQL DB is used as a back-end data store. It covers any Cloudant HTTP/JSON based
           native commands that can perform both database and document related Cloudant APIs that are very
           well documented for reference on the web or it covers the HBase related REST APIs.
        </description>
        <prototype>public stateful boolean dpsRunDataStoreCommand(uint32 cmdType, rstring httpVerb,
        	rstring baseUrl, rstring apiEndpoint, rstring queryParams, rstring jsonRequest,
        	mutable rstring jsonResponse, mutable uint64 err)</prototype>
      </function>   
      <function>
        <description>
           Base64 encode a given string. 
@param str the string to encode
@param encodedResultStr mutable parameter that will contain the encoded result.



		mutable list&lt;rstring>[5] cn = [];
		dpsBase64Encode("cf1:Company", cn[0]);
		dpsBase64Encode("IBM", cn[1]);
		dpsBase64Encode("Microsoft", cn[2]);
		dpsBase64Encode("Amazon", cn[3]);
		dpsBase64Encode("Google", cn[4]);
		
		//the cn array will now contain the decoded values
        </description>
        <prototype>public stateful void dpsBase64Encode(rstring str, mutable rstring encodedResultStr)</prototype>
      </function>
      <function>
        <description>
           Base64 decode a given string. 
@param str the string to decode
@param decodedResultStr mutable parameter that will contain the decoded result.
		rstring base64EncodedString = "bXlEQlN0b3JlMQ==";
		mutable rstring base64DecodedString = "";
		// Following DPS API will result in this clear text: "myDBStore1"
		dpsBase64Decode(rowKey, base64DecodedString);

        </description>
        <prototype>public stateful void dpsBase64Decode(rstring str, mutable rstring decodedResultStr)</prototype>
      </function>       
    </functions>
    <dependencies>
      <library>
        <cmn:description>Distributed process store library</cmn:description>
        <cmn:managedLibrary>
		  <cmn:lib>DistributedProcessStoreLib</cmn:lib>
          <cmn:lib>memcached</cmn:lib>
          <cmn:lib>sds</cmn:lib>
          <cmn:lib>hiredis</cmn:lib>
          <cmn:lib>uv</cmn:lib>
          <cmn:lib>crypto</cmn:lib>
          <cmn:lib>ssl</cmn:lib>
          <cmn:lib>cassandra</cmn:lib>
          <cmn:lib>curl</cmn:lib>
          <cmn:lib>json-c</cmn:lib>
          <cmn:lib>bson</cmn:lib>
          <cmn:lib>mongoc</cmn:lib>
          <cmn:lib>couchbase</cmn:lib>
          <cmn:lib>lua</cmn:lib>
          <cmn:lib>aerospike</cmn:lib>
          <cmn:command>../../../../impl/bin/archLevel</cmn:command>
        </cmn:managedLibrary>
      </library>
    </dependencies>
  </functionSet>
</functionModel>