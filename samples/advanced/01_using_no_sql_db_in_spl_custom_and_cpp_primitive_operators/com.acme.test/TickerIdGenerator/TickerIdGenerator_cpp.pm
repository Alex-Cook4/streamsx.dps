
package TickerIdGenerator_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/* Additional includes go here */', "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   print '// Constructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '{', "\n";
   print '    // Initialization code goes here', "\n";
   print '}', "\n";
   print "\n";
   print '// Destructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    // Finalization code goes here', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify port readiness', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '    // Notifies that all ports are ready. No tuples should be submitted before', "\n";
   print '    // this. Source operators can use this method to spawn threads.', "\n";
   print "\n";
   print '    /*', "\n";
   print '      createThreads(1); // Create source thread', "\n";
   print '    */', "\n";
   print '}', "\n";
   print ' ', "\n";
   print '// Notify pending shutdown', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    // This is an asynchronous call', "\n";
   print '}', "\n";
   print "\n";
   print '// Processing for source and threaded operators   ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t idx)', "\n";
   print '{', "\n";
   print '    // A typical implementation will loop until shutdown', "\n";
   print '    /*', "\n";
   print '      while(!getPE().getShutdownRequested()) {', "\n";
   print '          // do work ...', "\n";
   print '      }', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for mutating ports ', "\n";
   print '//', "\n";
   print '// What is the simple business logic being performed here?', "\n";
   print '// This primitive operator will pull out the "ticker symbol and the company name" from Thing1_Store ONLY for', "\n";
   print '// those ticker symbols sent in the stock picks list as an input tuple attribute.', "\n";
   print '// Then, it will create a unique ticker id for every ticker symbol specified in the stock picks list and insert ', "\n";
   print '// "ticker symbol => unique ticker id" in a new store called "Thing2_Store".', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '	// Our input tuple has only one attribute that is of type list<rstring>.', "\n";
   print '	// That attribute carries the caller\'s favorite stock picks.', "\n";
   print '	// Let us get that now.', "\n";
   print '	ValueHandle handle1 = tuple.getAttribute(0); // Access it by attribute position.', "\n";
   print '	List & list = handle1;', "\n";
   print '	SPL::list<rstring> & list1 = static_cast<SPL::list<rstring> &> (list);', "\n";
   print '	// Let us get the store id for the "Thing1 store", where the complete set of', "\n";
   print '	// "ticker symbol to company name" mappings are kept.', "\n";
   print '	uint64 e1 = 0;', "\n";
   print '	uint64 & err = static_cast<uint64 &> (e1);', "\n";
   print '	// Pass a dummy key and dummy value as method arguments.', "\n";
   print '	rstring dummyRstring = "";', "\n";
   print '    uint64 t1s = dpsCreateOrGetStore("Thing1_Store", dummyRstring, dummyRstring, err);', "\n";
   print '    ', "\n";
   print '    if (t1s == 0) {', "\n";
   print '    	cout << "TickerIdGenerator: Unable to get the store id for Thing1_Store." << endl;', "\n";
   print '    	SPL::Functions::Utility::abort("TickerIdGenerator_cpp.cgt", 66);', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Let us create a brand new store called "Thing2_Store".', "\n";
   print '    uint64 t2s = dpsCreateOrGetStore("Thing2_Store", dummyRstring, dummyRstring, err);', "\n";
   print '    ', "\n";
   print '    if (t2s == 0) {', "\n";
   print '    	cout << "TickerIdGenerator: Unable to create a new store called Thing2_Store." << endl;', "\n";
   print '    	SPL::Functions::Utility::abort("TickerIdGenerator_cpp.cgt", 74);', "\n";
   print '    } ', "\n";
   print '    ', "\n";
   print '    int32 listSize = SPL::Functions::Collections::size(list1);', "\n";
   print '    // Now loop through the stock picks list.', "\n";
   print '	for (int32 cnt=0; cnt<listSize; cnt++) {', "\n";
   print '    	rstring tickerSymbol = list1[cnt];', "\n";
   print '    	rstring cn = "";', "\n";
   print '    	rstring & companyName = static_cast<rstring &> (cn);', "\n";
   print '    	// Look up the company name for a given ticker symbol from the "Thing1_Store".', "\n";
   print '    	boolean res = false;', "\n";
   print '    	res = dpsGet(t1s, tickerSymbol, companyName, err);', "\n";
   print '    	', "\n";
   print '    	if (res == false) {', "\n";
   print '    		cout << "TickerIdGenerator: Unable to get the company name from Thing1_Store for ticker symbol " << tickerSymbol << "." << endl;', "\n";
   print '    		SPL::Functions::Utility::abort("TickerIdGenerator_cpp.cgt", 89);    	', "\n";
   print '    	}', "\n";
   print '    	', "\n";
   print '    	// Let us compute a unique hash code for this company name.', "\n";
   print '    	uint64 tickerId = companyName.hashCode();', "\n";
   print '    	// Put this away in the Thing2_Store now.', "\n";
   print '    	res = dpsPut(t2s, tickerSymbol, tickerId, err);', "\n";
   print "\n";
   print '    	if (res == false) {', "\n";
   print '    		cout << "TickerIdGenerator: Unable to put the tickerId " << tickerId << " for the ticker symbol " <<', "\n";
   print '    			tickerSymbol << " in the Thing2_Store." << endl;', "\n";
   print '    		SPL::Functions::Utility::abort("TickerIdGenerator_cpp.cgt", 100);    	', "\n";
   print '    	}    	   	', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // We finished creating a new Thing2_Store and created/inserted "TickerSymbol => TickerId" entries in it.', "\n";
   print '    OPort0Type otuple;', "\n";
   print '	ValueHandle handle2 = otuple.getAttributeValue("dummy");', "\n";
   print '	int32 & dummy = handle2;', "\n";
   print '	// Set any value to this attribute.', "\n";
   print '	dummy = 77;', "\n";
   print '	// Send this dummy tuple away to a downstream operator to indicate ticker ids were generated successfully.', "\n";
   print '    submit(otuple, 0); // submit to output port 0', "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for non-mutating ports', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    // Sample submit code', "\n";
   print '    /* ', "\n";
   print '      OPort0Type otuple;', "\n";
   print '      submit(otuple, 0); // submit to output port 0', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print '// Punctuation processing', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    /*', "\n";
   print '      if(punct==Punctuation::WindowMarker) {', "\n";
   print '        // ...;', "\n";
   print '      } else if(punct==Punctuation::FinalMarker) {', "\n";
   print '        // ...;', "\n";
   print '      }', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
